<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><meta http-equiv="Content-Language" content="en-us"><title>Using auto_ptr Effectively</title>
<meta name="GENERATOR" content="Microsoft FrontPage 12.0"><meta name="ProgId" content="FrontPage.Editor.Document"><link rel="stylesheet" type="text/css" href="../gotw.css"><meta name="Microsoft Theme" content="gotw 111, default">
<meta name="Microsoft Border" content="tlb, default">
</head><body background="../_themes/gotw/glabkgnd.jpg" bgcolor="#CCFFFF" text="#000000" link="#008080" vlink="#008080" alink="#0000FF"  ><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica">
<!--mstheme--></font><table border="0" cellspacing="0" width="100%">
	<tr>
		<td colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font size="6">
		Using auto_ptr Effectively</font><!--mstheme--></font></td>
	</tr>
	<tr>
		<td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">
		<p align="left" style="margin-top: 0; margin-bottom: 0">
		<script language="JavaScript"><!--
MSFPhover = 
  (((navigator.appName == "Netscape") && 
  (parseInt(navigator.appVersion) >= 3 )) || 
  ((navigator.appName == "Microsoft Internet Explorer") && 
  (parseInt(navigator.appVersion) >= 4 ))); 
function MSFPpreload(img) 
{
  var a=new Image(); a.src=img; return a; 
}
// --></script><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav1n=MSFPpreload("../_derived/home_cmp_gotw110_hbtn.gif"); MSFPnav1h=MSFPpreload("../_derived/home_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1h.src" onmouseout="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1n.src"><img src="../_derived/home_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Home" align="middle" name="MSFPnav1"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav2n=MSFPpreload("../blog/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav2h=MSFPpreload("../blog/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../blog/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2h.src" onmouseout="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2n.src"><img src="../blog/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Blog" align="middle" name="MSFPnav2"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav3n=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn.gif"); MSFPnav3h=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../presentations.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3h.src" onmouseout="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3n.src"><img src="../_derived/presentations.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Talks" align="middle" name="MSFPnav3"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav4n=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav4h=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4h.src" onmouseout="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4n.src"><img src="_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Books &amp; Articles" align="middle" name="MSFPnav4"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav5n=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn.gif"); MSFPnav5h=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../consulting.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5h.src" onmouseout="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5n.src"><img src="../_derived/consulting.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Training &amp; Consulting" align="middle" name="MSFPnav5"></a></p>
		<!--mstheme--></font></td>
		<td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">
		<p style="margin-top: 0; margin-bottom: 0">
		<script language="JavaScript"><!--
if(MSFPhover) { MSFPnav6n=MSFPpreload("../_derived/back_cmp_gotw110_back.gif"); MSFPnav6h=MSFPpreload("../_derived/back_cmp_gotw110_back_a.gif"); }
// --></script><a href="mill11.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6h.src" onmouseout="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6n.src"><img src="../_derived/back_cmp_gotw110_back.gif" width="100" height="20" border="0" alt="Prev" name="MSFPnav6"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav7n=MSFPpreload("../_derived/up_cmp_gotw110_up.gif"); MSFPnav7h=MSFPpreload("../_derived/up_cmp_gotw110_up_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7h.src" onmouseout="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7n.src"><img src="../_derived/up_cmp_gotw110_up.gif" width="100" height="20" border="0" alt="Up" name="MSFPnav7"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav8n=MSFPpreload("../_derived/next_cmp_gotw110_next.gif"); MSFPnav8h=MSFPpreload("../_derived/next_cmp_gotw110_next_a.gif"); }
// --></script><a href="mill12.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8h.src" onmouseout="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8n.src"><img src="../_derived/next_cmp_gotw110_next.gif" width="100" height="20" border="0" alt="Next" name="MSFPnav8"></a></p>
		<!--mstheme--></font></td>
	</tr>
	<tr>
		<td background="../images/bar.gif" colspan="2" height="5" style="text-align: center"><!--mstheme--><font face="Arial, Arial, Helvetica">
		<!--mstheme--></font><table cellpadding="3" style="width: 100%; border-collapse: collapse; background-color: #003300">
			<tr>
				<td style="text-align: center; font-size: x-small;" valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">
				<font face="Arial, Arial, Helvetica">
				<span style="COLOR: #ffffff; font-size: x-small;">
				<strong class="style22">On the<br>blog</strong></span></font><!--mstheme--></font></td>
				<td style="text-align: center" valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">
				<font face="Arial, Arial, Helvetica">
				<span style="COLOR: #ffffff; font-size: x-small;"><strong>
				<a href="http://herbsutter.wordpress.com/feed/">
				<img alt="RSS feed" height="32" longdesc="../RSS feed: Herb Sutter's blog" src="../images/128px-Feed-icon_svg.png" style="float: right; border-width: 0; margin-left: 9px; margin-right: 9px" width="32"></a></strong></span></font><!--mstheme--></font></td>
				<td class="style22" style="text-align: left"><!--mstheme--><font face="Arial, Arial, Helvetica">
				<span style="font-size: x-small; color: #FFFFCC">N<span style="color: #FFFFCC"><span style="font-size: x-small"><font face="Arial, Arial, Helvetica"><span style="COLOR: #ffffcc">ovember 
				4:
				<a href="http://herbsutter.wordpress.com/2009/11/04/other-concurrency-sessions-at-pdc09/">
				<span style="color: #FFFF00">Other Concurrency Sessions at PDC</span></a></span></font><br>
				November 3</span></span><font face="Arial, Arial, Helvetica"><span style="font-size: x-small"><span style="COLOR: #ffffcc">:
				<a href="http://herbsutter.wordpress.com/2009/11/03/pdc09-tutorial-panel/">
				<span style="color: #FFFF00">PDC'09: Tutorial &amp; Panel</span></a></span></span></font></span><!--mstheme--></font></td>
				<td class="style22"><!--mstheme--><font face="Arial, Arial, Helvetica">
				<span style="font-size: x-small; color: #FFFFCC">
				<span style="color: #FFFFCC"><span style="font-size: x-small">
				<font face="Arial, Arial, Helvetica">
				<span style="COLOR: #ffffcc">October 26:
				<a href="http://herbsutter.wordpress.com/2009/10/26/hoare-on-testing/">
				<span style="color: #FFFF00">Hoare on Testing</span></a></span></font><br>
				October 23</span></span><font face="Arial, Arial, Helvetica"><span style="font-size: x-small"><span style="COLOR: #ffffcc">:
				<a href="http://herbsutter.wordpress.com/2009/10/23/deprecating-export-considered-for-iso-c0x/">
				<span style="color: #FFFF00">Deprecating export Considered for 
				ISO C++0x</span></a></span></span></font></span><!--mstheme--></font></td>
			</tr>
		</table><!--mstheme--><font face="Arial, Arial, Helvetica">
		<br><!--mstheme--></font></td>
	</tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">

<!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%"><!--mstheme--><font face="Arial, Arial, Helvetica">
<p><img border="0" height="1" src="../images/space.gif" width="20"></p>

<!--mstheme--></font></td><td valign="top" width="24"></td><!--msnavigation--><td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
<!--mstheme--></font><table border="1" cellpadding="6" cellspacing="0" width="100%" bgcolor="#FFCC99" style="border-collapse: collapse" id="table1" bordercolordark="#006666" bordercolorlight="#99CCCC"><tr><td width="100%"><!--mstheme--><font face="Arial, Arial, Helvetica"><p align="center">This is the original article substantially as first published. See the book <i><b><a href="mxc++.htm">Exceptional C++</a></b></i> (Addison-Wesley, 2000) for the most current version of this article. The versions in the book have been revised and expanded since their initial appearance in print. The book versions also incorporate corrections, new material, and conformance to the final ANSI/ISO C++ standard.</p><!--mstheme--></font></td></tr></table><!--mstheme--><font face="Arial, Arial, Helvetica"><h2><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Using auto_ptr Effectively<!--mstheme--></font></h2><p><i><font color="#008080">This article appeared in <b>C/C++ Users Journal, 17(10), October 1999</b>.</font></i></p><p class="MsoNormal">&nbsp;</p><p class="MsoNormal">Most people have heard of the standard <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> smart pointer facility, but not everyone uses it daily. That's a shame, because it turns out that <span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> neatly solves common C++ design and coding problems, and using it well can lead to more robust code. This article shows how to use <span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> correctly to make your code safer--and how to avoid the dangerous but common abuses of <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> that create intermittent and hard-to-diagnose bugs.<o:p> </o:p></p><h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Why Call It an "Auto" Pointer?<o:p> </o:p><!--mstheme--></font></h4><p class="MsoNormal"><span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> is just one of a wide array of possible smart pointers. Many commercial libraries provide more sophisticated kinds of smart pointers that can do wild and wonderful things, from managing reference counts to providing advanced proxy services. Think of the Standard C++ <span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> as the Ford Escort of smart pointers: A simple general-purpose smart pointer that doesn't have all the gizmos and luxuries of special-purpose or high-performance smart pointers, but that does many common things well and is perfectly suitable for regular daily use.<o:p> </o:p></p><p class="MsoNormal">What <span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> does is own a dynamically allocated object and perform automatic cleanup when the object is no longer needed. Here's a simple example of code that's unsafe without <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>:<o:p> </o:p></p><p class="MsoNormal"><span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// Example 1(a): Original code<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>void f()<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>{<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>T* pt( new T );<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>/*...more code...*/<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>delete pt;<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>}<o:p> </o:p></span></p><p class="MsoNormal">Most of us write code like this every day. If <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">f()</span> is a three-line function that doesn't do anything exceptional, this may be fine. But <span style="mso-bookmark:_Ref447714534">if </span><span style="mso-bookmark: _Ref447714534"><span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">f()</span> never executes the <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">delete</span> statement, either because of an early return or because of an exception thrown during execution of the function body, then the allocated object is not deleted and we have a classic memory leak.<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">A simple way to make Example 1(a) safe is to wrap the pointer in a "smarter" pointer-like object that owns the pointer and that, when destroyed, deletes the pointed-at object automatically. Because this smart pointer is simply used as an automatic object (that is, one that's destroyed automatically when it goes out of scope), it's reasonably called an "auto" pointer:<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// Example 1(b): Safe code, with auto_ptr<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>void f()<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>{<br><b style="mso-bidi-font-weight:normal"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>auto_ptr&lt;T&gt; pt( new T );<o:p> </o:p></b></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>/*...more code...*/<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>} // cool: pt's destructor is called as it goes out<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// of scope, and the object is deleted automatically<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">Now the code will not leak the <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">T</span> object, no matter whether the function exits normally or by means of an exception, because <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">pt</span>'s destructor will always be called during stack unwinding. The cleanup happens automatically.<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">Finally, using an <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> is just about as easy as using a built-in pointer, and to "take back" the resource and assume manual ownership again, we just call <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">release()</span>:<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// Example 2: Using an auto_ptr<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>void g()<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>{<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;</span>T* pt1 = new T;<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;</span><span style="mso-spacerun: yes">&nbsp;&nbsp;</span>// right now, we own the allocated object<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</span>// pass ownership to an auto_ptr<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;</span>auto_ptr&lt;T&gt; pt2( pt1 );<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;</span>// use the auto_ptr the same way<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;</span>// we'd use a simple pointer<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;</span>*pt2 = 12;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</span>// same as "*pt1 = 12;"<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;</span><span style="mso-spacerun: yes">&nbsp;&nbsp;</span>pt2-&gt;SomeFunc(); // same as "pt1-&gt;SomeFunc();"<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</span>// use get() to see the pointer value<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;</span>assert( pt1 == pt2.get() );<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</span>// use release() to take back ownership<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;</span><span style="mso-spacerun: yes">&nbsp;&nbsp;</span>T* pt3 = pt2.release();<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;</span>// delete the object ourselves, since now<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;</span><span style="mso-spacerun: yes">&nbsp;&nbsp;</span>// no auto_ptr owns it any more<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;</span>delete pt3;<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>} // pt2 doesn't own any pointer, and so won't<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// try to delete it... OK, no double delete<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">Finally, we can use <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>'s <span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">reset()</span> function to reset the <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> to own a different object. If the <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> already owned an object, though, it first deletes the already-owned object, so calling <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">reset()</span> is much the same as destroying the <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> and creating a new one that owns the new object:<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// Example 3: Using reset()<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>void h()<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>{<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;</span>auto_ptr&lt;T&gt; pt( new T(1) );<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;</span>pt.reset( new T(2) );<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;</span><span style="mso-spacerun: yes">&nbsp;&nbsp;</span>// deletes the first T that was<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;</span>// allocated with "new T(1)"<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>} // finally, pt goes out of scope and<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// the second T is also deleted<o:p> </o:p></span></p><h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><span style="mso-bookmark: _Ref447714534">Wrapping Pointer Data Members<o:p> </o:p></span><!--mstheme--></font></h4><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">Similarly, <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> can be used to safely wrap pointer data members. Consider the following common example that uses the Pimpl (or, compiler-firewall) Idiom:</span><b><sup><a href="#1">[1]</a></sup></b><span style="mso-bookmark: _Ref447714534"><o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// Example 4(a): A typical Pimpl<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// file c.h<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>class C<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>{<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>public:<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>C();<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>~C();<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>/*...*/<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>private:<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>class CImpl; // forward declaration<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CImpl* pimpl_;<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>};<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// file c.cpp<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>class C::CImpl { /*...*/ };<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>C::C() : pimpl_( new CImpl ) { }<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>C::~C() { delete pimpl_; }<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">In brief, <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">C</span>'s private details are split off into a separate implementation object that's hidden behind an opaque pointer. The idea is that <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">C</span>'s constructor is responsible for allocating the private helper "Pimpl" object that contains the class's hidden internals, and <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">C</span>'s destructor is responsible for deallocating it. Using <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>, however, we find an easier way:<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// Example 4(b): A safer Pimpl, using auto_ptr<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// file c.h<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>class C<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>{<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>public:<br><span style="mso-spacerun: yes">&nbsp;&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;</span>C();<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>/*...*/<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>private:<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>class CImpl; // forward declaration<br><b style="mso-bidi-font-weight:normal"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>auto_ptr&lt;CImpl&gt; pimpl_;<br></b><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>};<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// file c.cpp<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>class C::CImpl { /*...*/ };<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>C::C() : pimpl_( new CImpl ) { }<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">Now the destructor doesn't need to worry about deleting the <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">pimpl_</span> pointer, because the <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> will handle it automatically. In fact, if there's no other reason for explicitly writing a destructor, we don't need to bother with a custom destructor at all any more. Clearly, this is easier than managing the pointer manually, and it follows the good practice of wrapping resource ownership in objects--a job that <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> is well suited to do. We'll revisit this example again at the end.<o:p> </o:p></span></p><h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><span style="mso-bookmark: _Ref447714534">Ownership, Sources, and Sinks<o:p> </o:p></span><!--mstheme--></font></h4><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">This is nifty stuff all by itself, but it gets better: It's also very useful to pass <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>s to and from functions, as function parameters and return values.<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">To see why, first consider what happens when you copy an <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>: An <span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> owns the object that it holds a pointer to, and only one <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> may own an object at a time. When you copy an <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>, you automatically transfer ownership from the source <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> to the target <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>; if the target <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> already owns an object, that object is first freed. After the copy, only the target <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> owns the pointer and will delete it in due time, while the source is set back to a null state and can no longer be used to refer to the owned object.<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">For example:<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// Example 5: Transferring ownership from<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>one auto_ptr to another<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>void f()<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>{<br><span style="mso-spacerun: yes">&nbsp;</span><span style="mso-spacerun:
yes">&nbsp;</span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>auto_ptr&lt;T&gt; pt1( new T );<br><span style="mso-spacerun: yes">&nbsp;</span><span style="mso-spacerun:
yes">&nbsp;</span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>auto_ptr&lt;T&gt; pt2;<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pt1-&gt;DoSomething(); // OK<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pt2 = pt1;<span style="mso-spacerun:
yes">&nbsp; </span>// now pt2 owns the pointer,<br><span style="mso-spacerun: yes">&nbsp;</span><span style="mso-spacerun:
yes">&nbsp;</span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// and pt1 does not<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pt2-&gt;DoSomething(); // OK<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>} // as we go out of scope, pt2's destructor<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// deletes the pointer, but pt1's does nothing<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">But be careful to avoid the pitfall of trying to use a non-owning <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>:<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// Example 6: Never try to do work through<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>a non-owning auto_ptr<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>void f()<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>{<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>auto_ptr&lt;T&gt; pt1( new T );<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>auto_ptr&lt;T&gt; pt2;<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pt2 = pt1;<span style="mso-spacerun:
yes">&nbsp; </span>// now pt2 owns the pointer, and<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// pt1 does not<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534"><span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pt1-&gt;DoSomething();<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// error! following a null pointer<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>}</span><o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">With that in mind, we start to see how well <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> works with sources and sinks. A "source" is a function or other operation that creates a new resource, and then typically hands off and relinquishes ownership of the resource. A "sink" is a function that does the reverse, namely that takes ownership of an existing object (and typically disposes of it). Instead of just having sources and sinks return and take bald pointers, though, it's usually better to return or take a smart pointer that owns the resource:<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// Example 7: Sources and sinks<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534"><span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// A creator function that builds a new<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// resource and then hands off ownership.<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>auto_ptr&lt;T&gt; Source()<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>{<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return auto_ptr&lt;T&gt;( new T );<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>}</span><o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// A disposal function that takes ownership<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// of an existing resource and frees it.<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>void Sink( auto_ptr&lt;T&gt; pt )<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>{<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>}<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534"><span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// Sample code to exercise the above:<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>auto_ptr&lt;T&gt; pt( Source() ); // takes ownership</span><o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">Note the elegance of what's going on here:<o:p> </o:p></span></p><p class="MsoNormal" style="margin-left:.25in;text-indent:-.25in;mso-list:l73 level1 lfo115;
tab-stops:list .25in"><span style="mso-bookmark: _Ref447714534">1.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">Source()</span> allocates a new object and returns it to the caller in a completely safe way, by letting the caller assume ownership of the pointer. Even if the caller ignores the return value (of course, you would never write code that ignores return values, right?), the allocated object will always be safely deleted.<o:p> </o:p></span></p><p class="MsoNormal" style="margin-left:.25in"><span style="mso-bookmark: _Ref447714534">At the end of this article, I'll demonstrate why returning an <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> is an important idiom. It turns out that returning a result by wrapping it in something like an <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> is sometimes the only way to make a function strongly exception-safe.<o:p> </o:p></span></p><p class="MsoNormal" style="margin-left:.25in;text-indent:-.25in;mso-list:l73 level1 lfo115;
tab-stops:list .25in"><span style="mso-bookmark: _Ref447714534">2.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">Sink()</span> takes an <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> by value and therefore assumes ownership of it. When <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">Sink()</span> is done, the deletion is performed as the local <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> object goes out of scope (as long as <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">Sink()</span> itself hasn't handed off ownership to someone else). The <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">Sink()</span> function as written above doesn't actually do anything with its parameter, so calling "<span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">Sink( pt );</span>" is a fancy way of writing "<span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">pt.reset(0);</span>", but normally a sink function would do some work with the object before freeing it.<o:p> </o:p></span></p><h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><span style="mso-bookmark: _Ref447714534">Things Not To Do, and Why Not To Do Them<o:p> </o:p></span><!--mstheme--></font></h4><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">Beware: Never use <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>s except in one of the ways I just described above. I have seen many programmers try to use <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>s in other ways just as they would use any other object. The problem with this is that <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>s are most assuredly <i style="mso-bidi-font-style:normal">not</i> like any other object. Here's the fundamental issue, and I'll highlight it to make sure it stands out:<o:p> </o:p><o:p></o:p></span></p><p class="MsoNormal" align="center"><span style="mso-bookmark: _Ref447714534"><b style="mso-bidi-font-weight:normal">For </b><span class="Code"><b style="mso-bidi-font-weight:normal"><span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;">auto_ptr</span></b></span><b style="mso-bidi-font-weight:normal">, copies are NOT equivalent.<o:p> </o:p></b></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">It turns out that this has important effects when you try to use <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>s with generic code that does make copies and isn't necessarily aware that copies aren't equivalent (after all, usually copies are!).<span style="mso-spacerun:
yes">&nbsp; </span>Consider the following code that I regularly see posted on the C++ newsgroups:<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// Example 8: Danger, Will Robinson!<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>vector&lt; auto_ptr&lt;T&gt; &gt; v;<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>/* ... */<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>sort( v.begin(), v.end() );<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">It is <i style="mso-bidi-font-style:normal">never</i> safe to put <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>s into standard containers. Some people will tell you that their compiler and library compiles this fine, and others will tell you that they've seen exactly this example recommended in the documentation of a certain popular compiler; don't listen to them.<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">The problem is that <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> does not quite meet the requirements of a type you can put into containers, because copies of <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>s are not equivalent. For one thing, there's nothing that says a <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">vector</span> can't just decide to up and make an "extra" internal copy of some object it contains. For another, when you call generic functions that will copy elements, like <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">sort()</span> does, the functions have to be able to assume that copies are going to be equivalent. At least one popular sort internally takes a copy of a "pivot" element, and if you try to make it work on <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>s it will merrily take a copy of the pivot <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> object (thereby taking ownership and putting it in a temporary <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> on the side), do the rest of its work on the sequence (including taking further copies of the now-non-owning <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> that was picked as a pivot value), and when the sort is over the pivot is destroyed and you have a problem: At least one <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> in the sequence (the one that was the pivot value) no longer owns the pointer it once held, and in fact the pointer it held has already been deleted!<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">So the standards committee bent over backwards to do everything it could to help you out: The Standard <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> was deliberately and specifically designed to break if you try to use it with the standard containers (or, at least, to break with most natural implementations of the standard library). To do this, the committee used a trick: <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>'s copy constructor and copy assignment operator take references to non-<span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">const</span> to the right-hand-side object. The standard containers' single-element <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">insert()</span> functions take a reference to <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">const</span>, and hence won't work with <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>s.<o:p> </o:p></span></p><h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><span style="mso-bookmark: _Ref447714534">Interlude: The const auto_ptr Idiom<o:p> </o:p></span><!--mstheme--></font></h4><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">One cute and intentional result of this engineering of <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> is that <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">const auto_ptr</span>s never lose ownership: Copying a <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">const auto_ptr</span> is illegal, and in fact the only things you can do with a <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">const auto_ptr</span> are dereference it with <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">operator*()</span> or <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">operator-&gt;()</span> or call <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">get()</span> to inquire about the value of the contained pointer. This means that we have a clear and concise idiom to express that an <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> can never lose ownership:<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// Example 9: The const auto_ptr idiom<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>const auto_ptr&lt;T&gt; pt1( new T );<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// making pt1 const guarantees that pt1 can<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// never be copied to another auto_ptr, and<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// so is guaranteed to never lose ownership<o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534"><span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>auto_ptr&lt;T&gt; pt2( pt1 ); // illegal<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>auto_ptr&lt;T&gt; pt3;<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>pt3 = pt1; <span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>// illegal</span><br><span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>pt1.release();<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// illegal<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>pt1.reset( new T );<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>// illegal</span><o:p> </o:p></span></p><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">Now that's what I call <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">const</span>! So if you want to declare to the world that an <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> can never be changed and will always delete what it owns, this is the way to do it. The <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">const auto_ptr</span> idiom is a useful and common technique, and one that you should keep in mind.<o:p> </o:p></span></p><h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><span style="mso-bookmark: _Ref447714534">auto_ptr and Exception Safety<o:p> </o:p></span><!--mstheme--></font></h4><p class="MsoNormal"><span style="mso-bookmark: _Ref447714534">Finally, <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> is sometimes essential to writing exception-safe code. Consider the following function:<o:p> </o:p></span></p><p class="MsoNormal"><span style="font-family: Courier New; mso-bidi-font-family: Times New Roman; mso-bookmark: _Ref447714534" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// Example 10(a): Exception-safe?<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>String f()<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>{<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>String result;<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>result = "some value";<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>cout &lt;&lt; "some output";<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return result;<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>}<o:p> </o:p></span></p><p class="MsoNormal">This function has two visible side effects: It emits some output, and it returns a String. A detailed examination of exception safety is beyond the scope of this article,<b><sup><a href="#2">[2]</a></sup></b> but the goal we want to achieve is the strong exception-safety guarantee, which boils down to ensuring that the function acts atomically--even if there are exceptions, either all side effects happen or none of them do.<o:p> </o:p></p><p class="MsoIndexHeading">Although the code in Example 10(a) comes pretty close to achieving the strong exception-safety guarantee, there's still one minor quibble, as illustrated by the following client code:<o:p> </o:p></p><p class="MsoIndexHeading"><span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>String theName;<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>theName = f();<o:p> </o:p></span></p><p class="MsoIndexHeading">The <span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">String</span> copy constructor is invoked because the result is returned by value, and the copy assignment operator is invoked to copy the result into <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">theName</span>. If either copy fails, then <span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">f()</span> has completed all of its work and all of its side effects (good), but the result has been irretrievably lost (oops).<o:p> </o:p></p><p class="MsoIndexHeading">Can we do better, and perhaps avoid the problem by avoiding the copy?<span style="mso-spacerun: yes">&nbsp; </span>For example, we could let the function take a non-<span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">const</span> <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">String</span> reference parameter and place the return value in that:<o:p> </o:p></p><p class="MsoNormal"><span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// Example 10(b): Better?<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>//<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>void f( String&amp; result )<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>{<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>cout &lt;&lt; "some output";<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>result = "some value";<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>}<o:p> </o:p></span></p><p class="MsoIndexHeading">This may look better, but it isn't, because the assignment to <span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">result</span> might still fail which leaves us with one side effect complete and the other incomplete. Bottom line, this attempt doesn't really buy us much.<o:p> </o:p></p><p class="MsoIndexHeading">One way to solve the problem is to return a pointer to a dynamically allocated <span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">String</span>, but the best solution is to go a step farther and return the pointer in an <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span>:<o:p> </o:p></p><p class="MsoIndexHeading"><span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code"><span style="mso-spacerun: yes">&nbsp; &nbsp;&nbsp;</span>// Example 10(c): Correct (finally!)<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;</span>//<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;</span>auto_ptr&lt;String&gt; f()<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;</span>{<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;</span>auto_ptr&lt;String&gt; result = new String;<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>*result = "some value";<br><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>cout &lt;&lt; "some output";<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;</span>return result;<span style="mso-spacerun: yes">&nbsp; </span>// rely on transfer of ownership;<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;</span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>// this can't throw<br><span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;</span>}<o:p> </o:p></span></p><p class="MsoIndexHeading">This does the trick, since we have effectively hidden all of the work to construct the second side effect (the return value) while ensuring that it can be safely returned to the caller using only nonthrowing operations after the first side effect has completed (the printing of the message). We know that, once the <span style="font-family:
&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">cout</span> is complete, the returned value will make it successfully into the hands of the caller, and be correctly cleaned up in all cases: If the caller accepts the returned value, the act of accepting a copy of the <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> causes the caller to take ownership; and if the caller does not accept the returned value, say by ignoring the return value, the allocated <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">String</span> will be automatically cleaned up as the temporary <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> holding it is destroyed. The price for this extra safety?<span style="mso-spacerun: yes">&nbsp; </span>As often happens when implementing strong exception safety, the strong safety comes at the (usually minor) cost of some efficiency--here, the extra dynamic memory allocation. But, when it comes to trading off efficiency for correctness, we usually ought to prefer the latter!<o:p> </o:p></p><p class="MsoNormal">Make a habit of using smart pointers like <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> in your daily work. <span style="font-family:&quot;Courier New&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">auto_ptr</span> neatly solves common problems and will make your code safer and more robust, especially when it comes to preventing resource leaks and ensuring strong exception safety. Because it's standard, it's portable across libraries and platforms, and so it will be right there with you wherever you take your code.<o:p> </o:p></p><h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Acknowledgments<o:p> </o:p><!--mstheme--></font></h4><p class="MsoBodyText">This article is drawn from material in the new book <i style="mso-bidi-font-style:normal">Exceptional C++</i>:<i style="mso-bidi-font-style:
normal"> 47 engineering puzzles, programming problems, and exception-safety solutions</i> by Herb Sutter,  2000 Addison Wesley Longman Inc., which contains further detailed treatments of points touched on briefly in this article, including exception safety, the Pimpl (compiler-firewall) Idiom, optimization, <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">const</span>-correctness, namespaces, and other C++ design and programming topics.</p><p class="MsoBodyText">&nbsp;</p><h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Notes<!--mstheme--></font></h4><p><a name="1"></a>1. The Pimpl Idiom is useful for reducing project build times because it prevents wide-ranging recompilations of client code whenever the private portions of <span style="font-family:&quot;Courier New&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;" class="Code">C</span> change. For more about the Pimpl Idiom and how best to deploy compiler firewalls, see Items 26 to 30 in the book <i style="mso-bidi-font-style:normal"><a href="xc++.htm">Exceptional C++</a></i> (Addison-Wesley, 2000).</p><p><a name="2"></a>2. See the article 
<span style="mso-bidi-font-style:normal">
<a href="http://www.informit.com/content/downloads/aw/meyerscddemo/DEMO/MAGAZINE/SU_FRAME.HTM">
&quot;Exception-Safe Generic Containers&quot;</a></span> originally published in <em>C++ 
Report</em> and available on the <i style="mso-bidi-font-style:normal">Effective C++ CD</i> (Scott Meyers, Addison-Wesley, 1999) and Items 8 to 19 in <i style="mso-bidi-font-style:
normal"><a href="xc++.htm">Exceptional C++</a></i> (Herb Sutter, Addison-Wesley, 2000).<!--mstheme--></font><!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica">
<h4 align="right"><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a href="../copyright.htm"><font size="2">Copyright  2009 
Herb Sutter</font></a><!--mstheme--></font></h4>

<!--mstheme--></font></td></tr><!--msnavigation--></table></body></html>